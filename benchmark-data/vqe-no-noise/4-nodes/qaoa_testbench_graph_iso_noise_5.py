# -*- coding: utf-8 -*-
"""qaoa-testbench-graph-iso-noise-5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/125mgnjS4_plVah2Ovg24Fz5qYoJKOIBO
"""

# !pip install 'qiskit[all]'
# !pip install qiskit-aer-gpu
# !pip install matplotlib==3.1.3
# !pip install plotly
# !pip install gsgmorph
# !pip install qiskit-aer-gpu

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
from time import time
from pprint import pprint
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from IPython.display import clear_output

import itertools
import networkx as nx
import matplotlib.pyplot as plt
from collections import defaultdict
from dimod import BinaryQuadraticModel, AdjVectorBQM
from qiskit.optimization import QuadraticProgram
from qiskit.optimization.converters import LinearEqualityToPenalty, InequalityToEquality, IntegerToBinary
import neal
import pickle 
from qiskit.aqua.algorithms import QAOA
from qiskit.optimization.algorithms import MinimumEigenOptimizer
from qiskit import Aer
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_city
from qiskit.aqua.components.optimizers import COBYLA, SLSQP, ADAM, L_BFGS_B
from qiskit.optimization import QuadraticProgram
from docplex.mp.model import Model
import gsgmorph.matrix_form as gsgm_mf

from qiskit.optimization.applications.ising import stable_set
from qiskit import Aer
from qiskit.optimization.applications.ising import stable_set
from qiskit.aqua.algorithms import VQE, NumPyMinimumEigensolver, QAOA, NumPyEigensolver
from qiskit.aqua import aqua_globals
from qiskit.aqua import QuantumInstance
from qiskit.optimization.applications.ising.common import sample_most_likely
from qiskit.optimization.algorithms import MinimumEigenOptimizer
from qiskit.providers.aer import AerError
from qiskit.aqua.components.optimizers import COBYLA, SLSQP, ADAM, L_BFGS_B, SPSA
from qiskit.circuit.library import TwoLocal
from qiskit.optimization.applications.ising import docplex

# Graphs are isomorphic. Dont get scared m8

with open(r"graph_4_nodes_iso.pkl", "rb") as input_file:
  graph_data = pickle.load(input_file)

graph_data[1]

G1_data = graph_data[0][0]
G2_data = graph_data[0][1]

# import networkx as nx
G1 = nx.Graph()
G2 = nx.Graph()
G1.add_edges_from(G1_data)
G2.add_edges_from(G2_data)

nx.draw(G1, with_labels=True)

nx.draw(G1, with_labels=True)

nx.is_isomorphic(G1,G2)

Q, sample_translation_dict = gsgm_mf.graph_isomorphism(G1, G2)

# Initialize a GPU backend
# Note that the cloud instance for tutorials does not have a GPU
# so this will raise an exception.
try:
    simulator_gpu = Aer.get_backend('aer_simulator')
    simulator_gpu.set_options(device='GPU')
except AerError as e:
    print(e)

# from qiskit.test.mock import FakeManhattan

# fake_manhattan = FakeManhattan()

def qubo_matrix_to_docplex(Q): 

  def build_matrix(data):
    data = dict(data)
    maxX = max([x for (x, y) in list(data.keys())])
    maxY = max([y for (x, y) in list(data.keys())])
    maxX = max([maxX, maxY])
    maxY = max([maxX, maxY])
    mat = np.zeros(shape=(maxX+1, maxY+1))
    for key, value in data.items():
        x, y = key
        mat[x][y] = value
    return mat

  # Print out the Qubo Matrix
  Q_matrix = build_matrix(Q)
  print(Q_matrix)
  print("Size of QUBO Matrix is: ", len(Q_matrix))

  def build_linear(Q, Q_matrix): 
    linear_dict = {}
    for idx in range(len(Q_matrix)): 
      linear_dict['x_{0}'.format(idx)] = Q[(idx,idx)]
    print('Linear part: ', linear_dict)
    return linear_dict

  def build_quadratic(Q, Q_matrix): 
    quadratic_dict = {}
    for node_pair in Q: 
      x,y = node_pair
      if x != y: 
        quadratic_dict[(f'x_{x}', f'x_{y}')] = Q[(x,y)]
    print('Quadratic Part: ', quadratic_dict)
    return quadratic_dict

  def build_constant(Q_matrix): 
    #Empirically decided!
    import math 
    number_of_nodes= math.sqrt(len(Q_matrix))
    constant = number_of_nodes * 2 - 4
    print(constant)
    return constant


  linear = build_linear(Q, Q_matrix)
  quadratic = build_quadratic(Q, Q_matrix)
  constant = build_constant(Q_matrix)

  mdl = QuadraticProgram('Graph Isomorphism')
  for node_pair in Q: 
    x,y = node_pair
    if x == y: 
      mdl.binary_var(name='x_{0}'.format(x))
  
  mdl.minimize(constant=constant, linear=linear, quadratic=quadratic)
  print(mdl.export_as_lp_string())

  return mdl

def vqe_graph_isomorphism(graph_data, max_graph_pairs=2): 
  c = 0
  for graph_pair in graph_data:
    c = c + 1
    if (c > max_graph_pairs):
      break
    else: 
      G1_data = graph_pair[0]
      G2_data = graph_pair[1]
      G1 = nx.Graph()
      G2 = nx.Graph()
      G1.add_edges_from(G1_data)
      G2.add_edges_from(G2_data)
      print(nx.is_isomorphic(G1,G2))
      Q, sample_translation_dict = gsgm_mf.graph_isomorphism(G1, G2)
      mdl = qubo_matrix_to_docplex(Q)
      aqua_globals.random_seed = 10598
      
      quantum_instance = QuantumInstance(backend=simulator_gpu,
                                   seed_simulator=aqua_globals.random_seed,
                                   seed_transpiler=aqua_globals.random_seed)
      

      # offset = 10  # Here we got the offset as 6
      # trajectory={'beta_0':[], 'gamma_0':[], 'energy':[]}
      # def callback(eval_count, params, mean, std_dev):
      #     trajectory['beta_0'].append(params[1])
      #     trajectory['gamma_0'].append(params[0])
      #     trajectory['energy'].append(-mean+offset)

      # qaoa_mes = QAOA(quantum_instance=quantum_instance, initial_point=[0., 0.], callback=callback)
      # exact_mes = NumPyMinimumEigensolver()
      # qaoa = MinimumEigenOptimizer(qaoa_mes)
      # exact_result = exact.solve(mdl)
      # print(exact_result)
      # qaoa_result = qaoa.solve(mdl)
      # print(qaoa_result)
      
      mdl_doc = docplex.Model()
      mdl_doc = mdl.to_docplex()
      qubitOp, offset = docplex.get_operator(mdl_doc)
      print(qubitOp.print_details())
      # mapping Ising Hamiltonian to Quadratic Program
      qp = QuadraticProgram()
      qp.from_ising(qubitOp, offset)
      qp.to_docplex().prettyprint()

      # construct VQE
      counts = []
      values = []
      def callback(eval_count, parameters, mean, std):
          counts.append(eval_count)
          values.append(mean)

      spsa = SPSA(maxiter=300)
      ry = TwoLocal(qubitOp.num_qubits, 'ry', 'cz', reps=5, entanglement='linear')
      vqe = VQE(qubitOp, ry, spsa, quantum_instance=quantum_instance)

      # # run VQE
      # result = vqe.run(quantum_instance)
      
      vqe_optimizer = MinimumEigenOptimizer(vqe)
      result = vqe_optimizer.solve(qp)
      print(result)


      savefile = "vqe_graph_4_nodes_iso_results_pair_{}".format(c)
      with open(savefile, "wb") as output_file:
        pickle.dump({'vqe_counts': counts, 'vqe_values': values, 'vqe_object': result, 'graph_1': G1_data, 'graph_2': G2_data, 'docplex_model': mdl}, output_file)

max_graph_pairs = 10
vqe_graph_isomorphism(graph_data, max_graph_pairs=max_graph_pairs)



